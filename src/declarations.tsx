import { add, information, list } from 'ionicons/icons';
import { IonFab } from '@ionic/react';
const uuidv4 = require('uuid/v4');

export interface AppPage {
  url: string;
  icon: object;
  title: string;
}

export type OrderForm={
  nickname:string;
  destinationAddress:string;
  packageSize:number;
}

export const appPages: AppPage[] = [
  {
    title: 'Order Creator',
    url: '/add',
    icon: add
  },
  {
    title: 'Order List',
    url: '/list',
    icon: list
  },
  {
    title: 'Status Page',
    url: '/status',
    icon: information
  }
];


//Artifacts are pieces of data that are generated by events and become part of the order
export type Artifact={
  artifactName:string,value:any,parentEventId:string,units?:string,creationTime?:string
}

export type CreationDetails={
  destinationAddress:string; //where to? 
  packageSize:number; //How large a package (in cubic feet)
}

export type AssignementDetails={
  assignedTo:string; // Name temporarily, could be username, or user unique id in the future.
}


//Order status possiblities
export enum OrderStatuses{
  IDLE,
  OUT,
  FULFILLED,
  CANCELLED
}

//All current order lifecycle event types
export enum OrderEventTypes{
  CREATION,
  ASSIGNMENT,
  ACCEPTANCE,
  FULFILLMENT,
  REVIEW,
  CANCELLATION
}



//Base class containing members and the implementation for the constructor and the addArtifact method
export let BaseOrderEvent = class BaseOrderEvent {
  debug_messages:string[];    // Used for debugging, a call to Debugger.dump(<object>) will dump all debug logs 
  artifacts:Artifact[];       // Artifacts are pieces of information that are relevant to an order, and are created by events.
  orderType:OrderEventTypes;  // The order type
  id:string;                  // A unique identifier for the order


  /*
  Constructor initializes the values necessary for an event and logs the initialization and time
  */
  constructor(type:OrderEventTypes){
    this.orderType = type; 
    this.id = uuidv4();
    this.artifacts = [];
    this.debug_messages=[];
    this.debug_messages.push("BaseOrderEvent initialization occured at " + Date());
  }

  getId():string{
    return this.id;
  }

  getOrderType():OrderEventTypes{
    return this.orderType;
  }

  getDebugMessages():string[]{
    return this.debug_messages;
  }

  getArtifacts():Artifact[]{
    return this.artifacts;
  }

  // Add an artifact to this event
  addArtifact(artifactName:string,value:any,optional?:{key:string,value:string}[]){
    let artifact:Artifact = {"artifactName":artifactName,"value":value,"parentEventId":this.id};

    let optionalParams = {};

    if(optional){
      optional.forEach(param => {
        for(var key in artifact){
          if(key === param.key){
            console.log("key matches "+ param.key);
            console.log("value: " + param.value);
          }
        }
      });
    }
    
    this.artifacts.push(artifact);
  }

}


// Class representing an Event in which an Order is Created
// requires order details
export let CreationOrderEvent = class CreationOrderEvent extends BaseOrderEvent{
  constructor(creationDetails:CreationDetails){
    super(OrderEventTypes.CREATION); // Self explanatory
    this.addArtifact("creation_time", + new Date()); // Add order creation time
    this.addArtifact("destination",creationDetails.destinationAddress); // Add order destination
    this.addArtifact("orderStatus",OrderStatuses.IDLE); // Add order status
    this.addArtifact("package_size",creationDetails.packageSize)
  }
}

// Class representing an Event in which an Order is Assigned to a 'fulfillment specialist'
let AssignementOrderEvent = class CreationOrderEvent extends BaseOrderEvent{
  constructor(assignmentDetails:AssignementDetails){
    super(OrderEventTypes.ASSIGNMENT); // Self explanatory
    this.addArtifact("assigned_at",+ new Date()) // Add order assignment time
    this.addArtifact("assigned_to", assignmentDetails.assignedTo ) // Add who it was assigned to
  }
}

class OrderEventTimeline{
  eventList: any[]=[];
  constructor(){
    
  }

  registerEvent(event:any){
    this.eventList.push(event);
  }

}

export class OrderFulfillmentJob{
  name:string = "Job"
  id:string;
  artifacts:Artifact[];
  eventTimeline:OrderEventTimeline = new OrderEventTimeline();
  debug_messages:string[] = [];

  constructor(name:string,uuid?:string){    
    if(!uuid){
      this.id = uuidv4();
    }else{
      this.id = uuid;
    }
    this.name = name;
    this.artifacts = [];
  }

  addEvent(event: typeof BaseOrderEvent.prototype){
    console.log(event.getArtifacts());
    let newArtifacts:Artifact[] = [];
    event.artifacts.map(artifact=>{
      //Edit artifacts as they come in here
      newArtifacts.push(artifact)
    })
    this.artifacts.push(...event.artifacts);
    this.eventTimeline.registerEvent(event);
  }

  // getLatestPropFromArtifactsByName(name:string){
  //   if(this.artifacts.length == 0){
  //     this.debug_messages.push("Attempted to extract artifact: " + name + " when no artifacts are loaded");
  //     return null;
  //   }else{
  //     let matches:Artifact[] = [];
  //     this.artifacts.map(artifact=>{
  //       if(artifact.artifactName===name){
  //         matches.push(artifact);
  //       }
  //     })
  //     if(matches.length == 0){
  //       this.debug_messages.push("Attempted to extract prop " + name + ", but no prop existed");
  //       return null;
  //     }else{
  //       let latest:Artifact=matches[0];
  //       matches.map(match=>{
  //         if(latest)
  //       })
  //     }
  //    }
  //  }

  getReadableName=()=>{
    return this.name;
  }

}

