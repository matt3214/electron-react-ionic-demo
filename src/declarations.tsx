import { add, information, list } from 'ionicons/icons';
import uuidv4 from 'uuid/v4';

import store,{clear,get,set} from 'local-storage';
import localForage from "localforage"

export interface AppPage {
  url: string;
  icon: object;
  title: string;
}

export type OrderForm={
  nickname:string;
  destinationAddress:string;
  packageSize:number;
}

export const appPages: AppPage[] = [
  {
    title: 'Order Creator',
    url: '/add',
    icon: add
  },
  {
    title: 'Order List',
    url: '/list',
    icon: list
  },
  {
    title: 'Status Page',
    url: '/status',
    icon: information
  }
];


//Artifacts are pieces of data that are generated by events and become part of the order
export type Artifact={
  artifactName:string,value:any,parentEventId:string,creationTime:string,units?:string
}

export type CreationDetails={
  destinationAddress:string; //where to? 
  packageSize:number; //How large a package (in cubic feet)
  nickname:string; //a name for the order
}

export type AssignementDetails={
  assignedTo:string; // Name temporarily, could be username, or user unique id in the future.
}


//Order status possiblities
export enum OrderStatuses{
  IDLE="Idle",
  OUT="Out",
  FULFILLED="Fulfilled",
  CANCELLED="Cancelled"
}


//All current order lifecycle event types
export enum OrderEventTypes{
  CREATION,
  ASSIGNMENT,
  ACCEPTANCE,
  FULFILLMENT,
  REVIEW,
  CANCELLATION
}



//Base class containing members and the implementation for the constructor and the addArtifact method
export let BaseOrderEvent = class BaseOrderEvent {
  debug_messages:string[];    // Used for debugging, a call to Debugger.dump(<object>) will dump all debug logs 
  artifacts:Artifact[];       // Artifacts are pieces of information that are relevant to an order, and are created by events.
  orderType:OrderEventTypes;  // The order type
  id:string;                  // A unique identifier for the order


  /*
  Constructor initializes the values necessary for an event and logs the initialization and time
  */
  constructor(type:OrderEventTypes){
    this.orderType = type; 
    this.id = uuidv4();
    this.artifacts = [];
    this.debug_messages=[];
    this.debug_messages.push("BaseOrderEvent initialization occured at " + Date());
  }

  getId():string{
    return this.id;
  }

  getOrderType():OrderEventTypes{
    return this.orderType;
  }

  getDebugMessages():string[]{
    return this.debug_messages;
  }

  getArtifacts():Artifact[]{
    return this.artifacts;
  }

  // Add an artifact to this event
  addArtifact(artifactName:string,value:any,optional?:{key:string,value:string}[]){
    let artifact:Artifact = {"artifactName":artifactName,"value":value,"parentEventId":this.id,"creationTime":Date()};

    let optionalParams = {};

    if(optional){
      optional.forEach(param => {
        for(var key in artifact){
          if(key === param.key){
            console.log("key matches "+ param.key);
            console.log("value: " + param.value);
          }
        }
      });
    }
    
    this.artifacts.push(artifact);
  }

}


// Class representing an Event in which an Order is Created
// requires order details
export let CreationOrderEvent = class CreationOrderEvent extends BaseOrderEvent{
  constructor(creationDetails:CreationDetails){
    super(OrderEventTypes.CREATION); // Self explanatory
    this.addArtifact("nickname", creationDetails.nickname); // Add order creation time
    this.addArtifact("eventCreationTime", + new Date()); // Add order creation time
    this.addArtifact("destinationAddress",creationDetails.destinationAddress); // Add order destination
    this.addArtifact("orderStatus",OrderStatuses.IDLE); // Add order status
    this.addArtifact("packageSize",creationDetails.packageSize) // Add the package size
  }
}

// Class representing an Event in which an Order is Assigned to a 'fulfillment specialist'
let AssignementOrderEvent = class CreationOrderEvent extends BaseOrderEvent{
  constructor(assignmentDetails:AssignementDetails){
    super(OrderEventTypes.ASSIGNMENT); // Self explanatory
    this.addArtifact("assignedAt",+ new Date()) // Add order assignment time
    this.addArtifact("assignedTo", assignmentDetails.assignedTo ) // Add who it was assigned to
  }
}

class OrderEventTimeline{
  eventList: any[]=[];
  constructor(){
    
  }

  registerEvent(event:any){
    this.eventList.push(event);
  }

}

export class OrderFulfillmentJob{
  name:string = "Default Job"
  id:string = "";
  artifacts:Artifact[] = [];
  eventTimeline:OrderEventTimeline = new OrderEventTimeline();
  debug_messages:string[] = [];

  constructor(obj?:any) {
    if (obj){
      Object.assign(this, obj);
    }else{
      this.id = uuidv4();
      this.artifacts = [];
    }
  }

  addEvent(event: typeof BaseOrderEvent.prototype){
    console.log(event.getArtifacts());
    let newArtifacts:Artifact[] = [];
    event.artifacts.map(artifact=>{
      //Edit artifacts as they come in here if needed
      if(artifact.artifactName == "nickname"){
        this.name = artifact.value;
      }
      newArtifacts.push(artifact)
    })
    this.artifacts.push(...event.artifacts);
    this.eventTimeline.registerEvent(event);
  }

  getPropByName(name:string){
    if(this.artifacts.length == 0){
      this.debug_messages.push("Attempted to extract artifact: " + name + " when no artifacts are loaded");
      return null;
    }else{
      let matches:Artifact[] = [];
      this.artifacts.map(artifact=>{
        if(artifact.artifactName===name){
          matches.push(artifact);
        }
      })
      if(matches.length == 0){
        this.debug_messages.push("Attempted to extract prop " + name + ", but no prop existed");
        return null;
      }else{
        let latest:Artifact=matches[0];
        matches.map(match=>{
          if(latest.creationTime < match.creationTime){
            latest = match;
          }
        })
        return latest.value;
      }
     }
   }

  getReadableName=()=>{
    return this.name;
  }

  static toStorable=(job:OrderFulfillmentJob)=>{
    return {
      _class:'OrderFulfillmentJob',
      name:job.name,
      id:job.id,
      artifacts:job.artifacts,
      eventTimeline:job.eventTimeline,
      debug_messages:job.debug_messages
    }
  }

  toStorage(){
    clear();
    store('entry0',this);
    console.log(this);
    let obj;
    try{
      obj = get('entry0');
    }catch(e){
      console.log(e);
    }

    obj = new OrderFulfillmentJob(obj);
    console.log(obj);
    console.log("They are the same? : " + (obj==this));
  }



}

export class JobManager{
  jobOrderList:OrderFulfillmentJob[] = [];

  pushOrder:any = (order:OrderForm)=>{
    let newOrderJob = new OrderFulfillmentJob(); // Create a new job with the nickname given
    newOrderJob.addEvent(new CreationOrderEvent({destinationAddress:order.destinationAddress,packageSize:order.packageSize,nickname:order.nickname})) // Add a creation event, could be consolidated into the constructor
    this.jobOrderList.push(newOrderJob); // add this job to the job list
  }
  printDebugMessages(){
    this.jobOrderList.forEach(element => {
      console.log("Order " + element.getReadableName() + " has messages: ");
      element.debug_messages.forEach(message=>{
        console.log(message);
      })
    });
  }

  
}

